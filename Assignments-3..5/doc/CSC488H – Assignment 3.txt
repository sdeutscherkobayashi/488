CSC488H – ASSIGNMENT 3GROUP 5PROFESSOR WORTMANSTEVEN DEUTSCHER-KOBAYASHI (G0KOBE)VIKY CHOW (G9CHOWPA)THURSDAY, MARCH 7TH 20131. High level package descriptionsASTContains node classes for the abstract syntax tree. All nodes support the doSemantics() method which is invoked during semantic analysis. Later these nodes will include doCodeGeneration().Expression nodes support type checking on their return types through the methods isBool() and isInt(). These methods are used extensively during semantic analysis.SymbolContains classes related to the SymbolTable datastructure. The SymbolTable is described as in lecture; each element is a SymbolTableEntry with a name, kind, value, and type.Semantics

The Semantics module manages scopes and the maintenance of their associated symbol tables. It also contains Exception classes needed duringsemantic analysis.      2. Abstract Syntax Tree DesignThe AST is constructed in parallel with syntax analysis by the parser. We used the real488.cup file provided as a starting point and attempted to make as few changes to the productions it provided. In addition we tried to change the AST classes as little as possible.3. Semantic Analysis DesignFor semantic analysis we chose to take approach 2 as described in the semantic analysis handout. We felt this approach was fairly intuitive and would set us up for the code generation assignment. Specifically there would be minimum infrastructure changes needed for code generation and we can focus mostly on adding addCodeGeneration() to the AST classes.Our semantic analysis is initiated through the Semantics class. It takes a Program object and calls its doSemantics() method. That Program object would then invoke the doSemantics() methods of its’ statements and declarations. This continues on as eventually the doSemantics() methods of all AST node classes in the tree would be called.While this is happening the AST classes are also interacting with the Semantics class which manages scopes and some other semantics such as loop depth on top of the AST classes. Scope ManagementThe scopes (SemanticsScope) managed by the Semantics module contain symbol tables and some additional information such as the loop depth of the current scope and the name of the routine being defined by the current scope (if there is one)SemanticsScopes are created where you would expect (when a scope production is invoked) they are present until all statements and declarations contained in that scope are done semantic analysis. In this way it is easy to find out whether a new entry to the symbol table is valid. Whenever some declarations is made we can simply check every scope for naming conflicts. This works because the deepest nodes in the AST are processed first.Unfortunately I believe I may have made some mistakes in my scope handing for function and procedure definitions. The following cannot be done,Begin  Integer x  Integer a_func(integer x)  Begin    Put x  End EndWith my current design function parameters share namespace with their containing scope and thus the parameter declaration of x results in a conflict. I am not sure if this is how things should work but I feel most likely this is wrong.4. Symbol Table DesignThe SymbolTable is implemented through a List type. Each entry of the list is of type SymbolTableEntry. This entry is defined similar to the one in lectures. It has a name attribute, which is the identifier of the declaration being made. It is the most important attribute as it must be unique amongst shared scopes. The kind attribute is an enumerated type (scalar, array, proc, func) which gives additional information about the entry.The value attribute is a pointer to the AST class being represented by the entry.The type attribute is as expected, the type of the declaration.The SymbolTable also has some methods that aid in management such as search, add, remove, contains, etc.The SymbolTable is meant to be simple, acting as a container while only being indirectly involved with the semantic analysis. 5. Work DistributionAST: Viky, StevenSymbolTable: Viky, StevenSemantic Analysis: StevenTesting: Viky, StevenDocumentation: StevenEven with a 1 week extension it was very difficult to complete this assignment. Viky is a part-time student working full time, and Steven is taking over a full course load. Due to this we were not really able to finish to the point where we would have liked. Testing is not really done properly, so I am suspecting there are bugs.6. TestingWe did testing for success and failure however both incomplete (with failure being way more incomplete) I wrote a short script to run all the success tests but did not have time to write something that actually counts which tests passed and failed. I had to rely on Exceptions and print statements.The failure tests are not written properly, but as stated I don’t have time to fix them. Currently each file is testing for many possible failures instead of just one each as it they should be.	